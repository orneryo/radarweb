<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Arduino Radar (USB OTG)</title>
<style>
  :root{--bg:#001100;--grid:rgba(0,255,0,0.12);--fg:rgba(0,255,0,0.95)}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .app {display:flex;flex-direction:column;height:100%;align-items:center;gap:.5rem;padding:.5rem}
  header{width:100%;display:flex;gap:.5rem;align-items:center;justify-content:space-between}
  .left{display:flex;gap:.5rem;align-items:center}
  button{background:transparent;border:1px solid var(--fg);color:var(--fg);padding:.4rem .6rem;border-radius:.4rem;font-size:0.95rem}
  select,input{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--fg);padding:.35rem;border-radius:.35rem}
  #canvasWrap{flex:1;display:flex;align-items:center;justify-content:center;width:100%}
  canvas{max-width:100%;height:auto;border-radius:.4rem;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
  footer{width:100%;display:flex;justify-content:space-between;gap:8px;align-items:center;padding:.3rem 0;font-size:.85rem}
  .small{opacity:.9;font-size:.9rem}
  .status{padding:.2rem .4rem;border-radius:.3rem;border:1px solid rgba(255,255,255,0.06)}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="left">
      <button id="connectBtn">Connect (USB)</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <label class="small">Baud:
        <select id="baud">
          <option>115200</option>
          <option>57600</option>
          <option>38400</option>
          <option>9600</option>
        </select>
      </label>
    </div>
    <div>
      <span class="small status" id="status">Not connected</span>
    </div>
  </header>

  <div id="canvasWrap">
    <canvas id="radar" width="600" height="600"></canvas>
  </div>

  <footer>
    <div class="small">Arduino → Serial CSV: <code>angle,distance_cm</code></div>
    <div class="small" id="info">Range scale: 400 cm</div>
  </footer>
</div>

<script>
/* Radar Serial Web App
   - Connect: requestPort(), open with chosen baud
   - Reads lines of CSV "angle,distance"
   - Draws radar on canvas, fades older points
*/

const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const statusEl = document.getElementById('status');
const infoEl = document.getElementById('info');
const baudSelect = document.getElementById('baud');

let port = null;
let reader = null;
let keepReading = false;

const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d', { alpha: false });

const W = canvas.width, H = canvas.height;
const cx = W/2, cy = H/2;
const maxRangeCm = 400; // default scale (change later if needed)
const maxPx = Math.min(W,H)/2 - 12;

// draw static background once
function drawBackground() {
  ctx.fillStyle = '#001100';
  ctx.fillRect(0,0,W,H);
  ctx.save();
  ctx.strokeStyle = 'rgba(0,255,0,0.12)';
  ctx.lineWidth = 1;
  for(let i=1;i<=4;i++){
    ctx.beginPath();
    ctx.ellipse(cx,cy,(maxPx*i/4),(maxPx*i/4),0,0,Math.PI*2);
    ctx.stroke();
  }
  ctx.strokeStyle = 'rgba(0,255,0,0.6)';
  ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,cy); ctx.lineTo(W,cy); ctx.stroke();
  ctx.restore();
}
drawBackground();

// fade overlay and draw data point
function showPoint(angleDeg, distanceCm) {
  // fade older points slightly
  ctx.fillStyle = 'rgba(0,0,0,0.06)'; // subtle fade
  ctx.fillRect(0,0,W,H);

  // Map distance → pixels
  const r = Math.min(maxPx, (distanceCm / maxRangeCm) * maxPx);
  const theta = (angleDeg - 90) * Math.PI/180.0; // rotate so 0 is up
  const x = cx + r * Math.cos(theta);
  const y = cy + r * Math.sin(theta);

  // point
  ctx.beginPath();
  ctx.fillStyle = 'rgba(0,255,0,0.98)';
  ctx.arc(x, y, 5, 0, Math.PI*2);
  ctx.fill();

  // faint sweep line
  ctx.strokeStyle = 'rgba(0,255,0,0.07)';
  ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(x,y); ctx.stroke();
}

// Serial reading helpers: read text lines
async function readLoop() {
  keepReading = true;
  const textDecoder = new TextDecoderStream();
  const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
  const streamReader = textDecoder.readable.getReader();

  let buffer = '';
  try {
    while (keepReading) {
      const { value, done } = await streamReader.read();
      if (done) break;
      if (value) {
        buffer += value;
        // split into lines
        let lines = buffer.split(/\r?\n/);
        buffer = lines.pop(); // last partial
        for (let ln of lines) {
          handleLine(ln.trim());
        }
      }
    }
  } catch (err) {
    console.error('Read loop error', err);
  } finally {
    streamReader.releaseLock();
  }
}

function handleLine(line) {
  if (!line) return;
  // Accept lines like: angle,distance  (e.g. "45,123")
  const parts = line.split(',');
  if (parts.length < 2) return;
  const a = parseFloat(parts[0]);
  const d = parseFloat(parts[1]);
  if (Number.isFinite(a) && Number.isFinite(d) && d > 0) {
    showPoint(a, d);
    statusEl.textContent = `Got ${a}°, ${d} cm`;
  }
}

// connect / open port
connectBtn.addEventListener('click', async () => {
  try {
    // feature detect
    if (!('serial' in navigator)) {
      alert('Web Serial API not supported by this browser. Use latest Chrome for Android.');
      return;
    }

    // request port (shows chooser)
    port = await navigator.serial.requestPort();
    const baud = Number(baudSelect.value || 115200);
    await port.open({ baudRate: baud });

    statusEl.textContent = `Connected @ ${baud} baud`;
    connectBtn.disabled = true;
    disconnectBtn.disabled = false;

    // start reading
    readLoop();

  } catch (err) {
    console.error(err);
    statusEl.textContent = 'Connection failed';
    alert('Failed to open serial: ' + err.message);
  }
});

// disconnect
disconnectBtn.addEventListener('click', async () => {
  keepReading = false;
  disconnectBtn.disabled = true;
  connectBtn.disabled = false;
  statusEl.textContent = 'Disconnecting...';
  try {
    if (port && port.readable) {
      // closing readable side will let readLoop finish
      await port.readable.cancel();
    }
    if (port) {
      await port.close();
    }
    statusEl.textContent = 'Disconnected';
  } catch (err) {
    console.warn('Error closing port', err);
    statusEl.textContent = 'Error closing';
  } finally {
    port = null;
  }
});

// touch-friendly: on double-tap clear canvas (redraw background)
canvas.addEventListener('dblclick', () => {
  drawBackground();
  statusEl.textContent = 'Cleared';
});

// handle page visibility (auto disconnect on unload)
window.addEventListener('beforeunload', async () => {
  try {
    keepReading = false;
    if (port) {
      await port.close();
    }
  } catch(e) {}
});

// initial info
infoEl.textContent = `Range scale: ${maxRangeCm} cm — rotate servo to scan`;
</script>
</body>
</html>
